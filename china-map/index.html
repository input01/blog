<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      html body {
        height: 100%;
        width: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden;
      }

      #tooltip {
        position: absolute;
        z-index: 2;
        background: rgb(251, 1, 1);
        padding: 10px;
        border-radius: 2px;
        left: 0;
        top: 0;
      }
    </style>
  </head>

  <body>
    <script src="../js/three.js"></script>
    <script src="../js/OrbitControls.js"></script>
    <script src="../js/d3-geo.v1.min.js"></script>
    <canvas id="canvas" width="100%" height="100%"></canvas>
    <div id="tooltip">我是一个很复杂的DIV</div>
    <script>
      class chinaMap {
        constructor() {
          this.init();
        }
        init() {
          // 第一步新建一个场景
          this.scene = new THREE.Scene();
          // 设置渲染器
          this.setRenderer();
          // 设置观察相机
          this.setCamera();
          // 设置鼠标交互控制器
          this.setController();
          // 设置拾取
          // this.setRaycaster();
          // 设置动画循环渲染
          this.animate();
          // 加载地图
          this.loadMapData();
          // 加载3d字体
          // this.addFont()
          // 添加调试辅助类
          this.addHelper();
        }

        addHelper() {
          this.axisHelper = new THREE.AxesHelper(1000);
          this.scene.add(this.axisHelper);

          //照相机帮助线
          // this.cameraHelper = new THREE.CameraHelper(this.camera);
          // this.scene.add(this.cameraHelper);
        }

        // 加载地图数据
        loadMapData() {
          // 异步请求JSON文件
          const loader = new THREE.FileLoader();
          loader.load("../json/china.json", (data) => {
            const jsondata = JSON.parse(data);
            // 生成3D场景内的物体
            this.generateGeometry(jsondata);
          });
        }

        generateGeometry(jsondata) {
          // 初始化一个地图对象, 相当于最外层的容器对象, 方便整体操作; 直接把容器内的对象添加到场景亦可.
          this.map = new THREE.Object3D();
          // 定义一个基于墨卡托投影的转换函数, 把GEOJSON的经纬度转换成二维直角坐标系.
          // 中心设置为AM, 营造聚焦效果
          const projection = d3
            .geoMercator()
            .center([113.665412, 34.757975])
            .translate([0, 0]);

          jsondata.features.forEach((elem) => {
            // 循环坐标数组
            const coordinates = elem.geometry.coordinates;
            coordinates.forEach((multiPolygon) => {
              multiPolygon.forEach((polygon) => {
                // 定义一个形状, 供把转换后的直角坐标放进去, 成为一个形状.
                const shape2D = new THREE.Shape();
                // 由于存在多个形状, 所以需要构造一个多形状的threejs几何物体
                const lineGeometry = new THREE.Geometry();
                for (let i = 0; i < polygon.length; i++) {
                  const [x, y] = projection(polygon[i]);
                  if (i === 0) {
                    shape2D.moveTo(x, -y);
                  }
                  shape2D.lineTo(x, -y);
                  lineGeometry.vertices.push(new THREE.Vector3(x, -y, 8.2));
                }
                // 至此, lineGeometry可以认为是一个省(可能多个独立边界, 比如带岛屿的省)的二维线条形状
                // 设置从二维拉伸到三维(即构造有厚度的地图)的参数
                // depth表示厚度, 没有单位, 或者说单位是抽象的"单位1"
                // bevelEnabled表示斜角, 由于垂直切面我们设计的没有斜角, 所以这里设置为false.
                const extrudeSettings = {
                  depth: 4,
                  bevelEnabled: false,
                };
                // 构造一个拉伸到三维(即构造有厚度的地图)的物体.
                const geometry3DMap = new THREE.ExtrudeGeometry(
                  shape2D,
                  extrudeSettings
                );
                // 定义一个前景色的二维物体(为了单独在最顶层, 做一个渐变的效果覆盖表面)
                const geometrySurface = new THREE.ShapeGeometry(shape2D);

                //// threejs里, 定义了物体, 还需要定义材料(即一个物体, 应该用什么颜色来着色), 二者组合起来才能被渲染.
                // 线条省边界的材料, 这里选择普通的灰白色, 画线用封装好的LineBasicMaterial类型材料.
                const boundaryMaterial = new THREE.LineBasicMaterial({
                  color: "#eeeeee",
                });

                // 顶层渐变覆盖面的材料, 需要用到复杂的着色器材质
                const materialSurface = new THREE.ShaderMaterial({
                  uniforms: {
                    topColor: { value: new THREE.Color(0x95c4f7) },
                    bottomColor: { value: new THREE.Color(0xb0d6ff) },
                  },
                  vertexShader: `
                                          varying vec3 vPosition;
                                          void main() {
                                              vPosition = position;
                                              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                                          }
                                          `,
                  fragmentShader: `
                                          varying vec3 vPosition;
                                          uniform vec3 topColor;
                                          uniform vec3 bottomColor;

                                          void main() {
                                              float percent = (vPosition.x - vPosition.y) / 40.0; // 计算当前像素点在立方体高度上的百分比
                                              vec3 color = mix(topColor, bottomColor, percent); // 根据百分比进行颜色插值
                                              gl_FragColor = vec4(color, 1.0); // 设置当前像素点的颜色
                                          }
                                          `,
                });

                // 自上而下第一层3D地图的材料, 浅蓝色的那个
                const materialFG = new THREE.MeshBasicMaterial({
                  color: "#8eb8e6",
                  // color: "#ff0000",
                });

                // 自上而下第二层3D地图的材料, 白色到黑色垂直渐变的那个(水平方向xy上的材料)
                const materialBG = new THREE.MeshBasicMaterial({
                  color: "#e5eef8",
                });

                // 自上而下第二层3D地图的材料, 白色到灰色阴影效果的渐变材料(垂直方向z上的材料)
                const gradientMaterial = new THREE.ShaderMaterial({
                  uniforms: {
                    topColor: { value: new THREE.Color(0xe5eef8) },
                    bottomColor: { value: new THREE.Color(0x989a9c) },
                  },
                  vertexShader: `
                                          varying vec3 vPosition;

                                          void main() {
                                              vPosition = position;
                                              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                                          }
                                          `,
                  fragmentShader: `
                                          varying vec3 vPosition;
                                          uniform vec3 topColor;
                                          uniform vec3 bottomColor;

                                          void main() {
                                              float percent = (vPosition.z + 0.5) / 2.0; // 计算当前像素点在立方体高度上的百分比
                                              vec3 color = mix(bottomColor, topColor, percent); // 根据百分比进行颜色插值
                                              gl_FragColor = vec4(color, 1.0); // 设置当前像素点的颜色
                                          }
                                          `,
                });

                // 创建可以放进渲染引擎的Mesh(物体形状描述 + 着色材料)
                // 顶层的线条
                const line = new THREE.Line(lineGeometry, boundaryMaterial);
                // 表面渐变2D地图
                const meshSurface = new THREE.Mesh(
                  geometrySurface,
                  materialSurface
                );
                // 第一层3D地图
                const meshFG = new THREE.Mesh(geometry3DMap, [
                  materialFG,
                  materialFG,
                ]);
                // 第二层3D地图
                const meshBG = new THREE.Mesh(geometry3DMap, [
                  materialBG,
                  gradientMaterial,
                ]);

                // 根据z坐标调整叠放顺序, 类似z-index
                line.position.z = -3.8;
                meshSurface.position.z = 4.2;
                meshFG.position.z = 0;
                meshBG.position.z = -4;

                // 遍历每个省的边界, 每个省的对象都放到这个对象里, 方便控制某个省的交互效果, 比如省的整体变色
                const province = new THREE.Object3D();
                // 每个省物体可以添加属性, 可供查找和交互显示
                province.properties = elem.properties;
                province.add(line);
                province.add(meshSurface);
                province.add(meshFG);
                province.add(meshBG);
                // 省添加到地图物体里
                this.map.add(province);
              });
            });
          });
          // 地图添加到场景中(添加到场景中的物体, 引擎会自动渲染)
          this.scene.add(this.map);

          // 测试一下小功能
          const [x_test, y_test] = projection([113.665412, 34.757975]);
          // const geometry = new THREE.BoxGeometry( 10, 10, 10 );
          // const material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
          // const cube = new THREE.Mesh( geometry, material );
          // cube.position.x = x_test;
          // cube.position.y = -y_test;
          // this.scene.add( cube );
          // 测试一下小功能结束

          // 将笛卡尔坐标系中的点转换为屏幕坐标
          var worldVector = new THREE.Vector3(x_test, -y_test, 8.2);
          worldVector.project(this.camera);

          // 获取物体的世界坐标
          const centerX = window.innerWidth / 2;
          const centerY = window.innerHeight / 2;

          const screenX = Math.round(centerX * worldVector.x + centerX);
          const screenY = Math.round(-centerY * worldVector.y + centerY);

          console.log("世界坐标：", worldVector.x, worldVector.y);
          this.tooltip = document.getElementById("tooltip");
          this.tooltip.style.left = screenX + "px";
          this.tooltip.style.top = screenY + "px";
          console.log("屏幕坐标：", screenX, screenY);
          this.tooltip.textContent = JSON.stringify("我是一个很复杂的div");
        }

        setController() {
          this.controller = new THREE.OrbitControls(
            this.camera,
            document.getElementById("canvas")
          );
        }

        // 新建透视相机, 类比现实中的拍照片
        setCamera() {
          // 第一个参数, 类比现实中人眼, 可以观察到左右多大的宽度
          // 第二个参数, window.innerWidth / window.innerHeight比例表示webgl坐标转换到浏览器canvas屏幕的时候, 坐标如何映射.
          // 第三个参数, 表示最近可以看到多近的物体, 超过就会被裁剪不再渲染
          // 第四个参数, 表示最远可以看到多远的物体, 超过就会被裁剪不再渲染
          this.camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
          );
          // 移动相机的位置, 选择一个合适的观察(拍照)位置
          this.camera.position.set(0, -80, 120);
          window.camera = this.camera;
          // 相机往哪个位置拍, 拍头和拍腿, 成像结果不一样
        }

        // 定义射线, 模拟激光拾取物体
        // setRaycaster() {
        //   this.raycaster = new THREE.Raycaster();
        //   this.mouse = new THREE.Vector2();
        //   this.tooltip = document.getElementById("tooltip");
        //   const onMouseMove = (event) => {
        //     this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        //     this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        //     this.tooltip.style.left = event.clientX + 2 + "px";
        //     this.tooltip.style.top = event.clientY + 2 + "px";
        //   };
        //   window.addEventListener("mousemove", onMouseMove, false);
        // }

        // 设置渲染器
        setRenderer() {
          this.renderer = new THREE.WebGLRenderer({
            canvas: document.getElementById("canvas"),
            alpha: true,
          });
          this.renderer.setPixelRatio(window.devicePixelRatio);
          // 设置画布的大小
          this.renderer.setSize(window.innerWidth, window.innerHeight);
        }

        render() {
          this.renderer.render(this.scene, this.camera);
        }

        animate() {
          requestAnimationFrame(this.animate.bind(this));
          
          // 通过摄像机和鼠标位置更新射线
          // this.raycaster.setFromCamera(this.mouse, this.camera);
          // // 算出射线 与当场景相交的对象有那些
          // const intersects = this.raycaster.intersectObjects(
          //   this.scene.children,
          //   true
          // );
          // this.lastPick = null;
          // this.lastPick = intersects.find(
          //   (item) => item.object.material && item.object.material.length === 2
          // );
          // this.showTip();
          this.render();
        }
        // 显示省份的信息
        // showTip() {
        //   if (this.lastPick) {
        //     const properties = this.lastPick.object.parent.properties;
        //     this.tooltip.textContent = properties.name;
        //     this.tooltip.style.visibility = "visible";
        //   } else {
        //     this.tooltip.style.visibility = "hidden";
        //   }
        // }
      }
      new chinaMap().init();
    </script>
  </body>
</html>
